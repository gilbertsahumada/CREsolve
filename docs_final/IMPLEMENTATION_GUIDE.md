# CREsolver — Implementation Guide

> **Estado**: Fases 1-3 completadas. Fase 4 (Deploy testnet + Polish) pendiente.
>
> Reference document with all implemented code. Located in `cresolver/`.

---

## Progress Summary

| Sección | Componente | Estado | Notas |
|---------|-----------|--------|-------|
| A | CREsolverMarket.sol | ✅ | Standalone market + staking + escrow + reputation + ERC-8004 |
| B | CREReceiver.sol | ✅ | KeystoneForwarder bridge |
| C | ReceiverTemplate.sol + IReceiver.sol | ✅ | Base contract + interface |
| D | CREsolverMarket.t.sol | ✅ | 27 tests (including 3 ERC-8004) |
| E | CREReceiver.t.sol | ✅ | 9 tests |
| F | Deploy.s.sol | ✅ | Deploy script |
| G | CRE Workflow | ✅ | main.ts + types.ts + agents.ts + evm.ts + evaluate.ts |
| H | Worker Agent | ✅ | TypeScript/Hono, mock + LLM modes |
| I | Scripts | ✅ | setup-demo.ts, demo-run.ts |
| J | E2E Docker Sandbox | ✅ | 18 tests, docker-compose + vitest |
| — | Deploy testnet | ⬜ | Fase 4 |
| — | WASM build para DON | ⬜ | Fase 4 |

---

## Repository Structure

```
cresolver/
├── package.json                        # Root scripts (yarn e2e)
├── docker-compose.e2e.yml              # E2E sandbox
├── .gitignore
├── contracts/                          # Foundry project
│   ├── foundry.toml
│   ├── src/
│   │   ├── CREsolverMarket.sol         # Standalone market contract
│   │   ├── CREReceiver.sol             # Keystone bridge → resolveMarket
│   │   └── interfaces/
│   │       ├── IReceiver.sol           # ERC165 interface
│   │       ├── ReceiverTemplate.sol    # Base CRE receiver
│   │       └── erc8004/
│   │           ├── IERC8004IdentityV1.sol  # ERC-8004 Identity interface
│   │           └── IERC8004Reputation.sol  # ERC-8004 Reputation interface
│   ├── test/
│   │   ├── CREsolverMarket.t.sol       # 16 tests
│   │   └── CREReceiver.t.sol           # 9 tests
│   ├── script/
│   │   └── Deploy.s.sol
│   └── lib/
│       ├── forge-std/
│       └── openzeppelin-contracts/
├── cre-workflow/                       # CRE resolution workflow
│   ├── project.yaml                    # CRE project metadata
│   ├── secrets.yaml                    # API keys (gitignored)
│   └── cresolver-resolution/
│       ├── workflow.yaml               # Workflow definition
│       ├── config.json                 # Agent endpoints + EVM config
│       ├── main.ts                     # Entry point (2 triggers)
│       ├── types.ts                    # Zod schemas + interfaces
│       ├── agents.ts                   # HTTP client for workers
│       ├── evm.ts                      # EVM client read/write
│       └── evaluate.ts                 # Scoring + consensus
├── agent/                              # TypeScript/Hono worker agent
│   ├── package.json
│   ├── Dockerfile                      # Node 20 alpine + tsx
│   ├── src/
│   │   ├── index.ts                    # Hono server entry
│   │   ├── config.ts                   # Environment config
│   │   ├── validation.ts              # Zod request schemas
│   │   ├── routes/
│   │   │   ├── health.ts              # GET /health
│   │   │   └── a2a.ts                 # POST /a2a/resolve, /a2a/challenge
│   │   └── services/
│   │       ├── investigator.ts        # Mock + LLM investigation
│   │       └── defender.ts            # Challenge defense
│   └── tests/
│       └── agent.test.ts
├── scripts/                            # Demo automation
│   ├── package.json
│   ├── setup-demo.ts                   # Deploy + fund + create markets
│   ├── demo-run.ts                     # Full resolution loop
│   └── demo-config.json                # Generated (gitignored)
├── e2e/                                # E2E test suite
│   ├── package.json
│   ├── vitest.e2e.config.ts
│   ├── demo-config.json                # Generated by setup profile e2e
│   ├── helpers.ts                      # Health poll + on-chain verify
│   ├── e2e.test.ts                     # 18 tests
│   └── workflow-runner.ts              # Local CRE DON simulator
├── shared/
│   └── types.ts                        # Shared TypeScript interfaces
└── docs_final/
    ├── BLUEPRINT.md                    # Architecture & design
    ├── IMPLEMENTATION_GUIDE.md         # This file
    ├── HACKATHON_ONE_PAGER.md          # Jury/demo summary
    └── PRIVACY_ROADMAP.md              # Privacy phased design
```

---

## CRE Architecture — KeystoneForwarder Pattern

> Chainlink CRE does **NOT** call arbitrary contract functions directly.
> CRE uses the **KeystoneForwarder** pattern: workflows produce a DON-signed report via
> `runtime.report()`, and the CRE runtime delivers it through `KeystoneForwarder.report()`,
> which calls `onReport(metadata, report)` on the receiver contract.

### Flow

```
CRE Workflow         CRE Runtime         KeystoneForwarder        CREReceiver         CREsolverMarket
     │                    │                      │                      │                      │
     │──runtime.report()─>│                      │                      │                      │
     │  (encoded payload) │──report()────────────>│                      │                      │
     │                    │  (DON-signed)         │──onReport(meta,rpt)─>│                      │
     │                    │                      │                      │──decode report────────│
     │                    │                      │                      │──resolveMarket()─────>│
     │                    │                      │                      │<──ok──────────────────│
     │                    │                      │<──ok─────────────────│                      │
```

### Key Details

- **IReceiver interface**: Receiver contracts must implement `onReport(bytes calldata metadata, bytes calldata report)` + ERC165
- **msg.sender**: Inside `onReport()`, `msg.sender` is the KeystoneForwarder address
- **Authorization**: `setAuthorizedResolver()` must authorize the **CREReceiver** address (not the forwarder)
- **Report encoding**: CRE workflow encodes `abi.encode(marketId, workers[], weights[], dimScores[], resolution)` with canonical blinded weights (no `determinations[]` on-chain)
- **CRE TEE references**:
  - Confidential HTTP + DON secrets + encrypted output: https://github.com/smartcontractkit/conf-http-demo
  - Private transfer with permissioning/compliance controls: https://github.com/smartcontractkit/Compliant-Private-Transfer-Demo

---

## PART A: SOLIDITY CONTRACTS

### A.1 CREsolverMarket.sol

**File**: `contracts/src/CREsolverMarket.sol`

Standalone contract that combines market management, worker registration, escrow, resolution, and reputation tracking in a single contract.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {IERC8004IdentityV1} from "./interfaces/erc8004/IERC8004IdentityV1.sol";
import {IERC8004Reputation} from "./interfaces/erc8004/IERC8004Reputation.sol";

contract CREsolverMarket is Ownable, ReentrancyGuard {
    // ─── Structs ───────────────────────────────────────────────────────
    struct Market { ... }
    struct Reputation { ... }

    // ─── ERC-8004 Registries (optional, address(0) = disabled) ────────
    IERC8004IdentityV1 public immutable identityRegistry;
    IERC8004Reputation public immutable reputationRegistry;

    // ─── State ─────────────────────────────────────────────────────────
    mapping(uint256 => Market) public markets;
    uint256 public marketCount;
    mapping(uint256 => mapping(address => uint256)) public stakes;
    mapping(uint256 => address[]) internal _marketWorkers;
    mapping(uint256 => mapping(address => uint256)) public workerAgentIds; // ERC-8004 agent IDs
    mapping(address => uint256) public balances;
    mapping(address => bool) public authorizedResolvers;
    mapping(address => Reputation) public reputation;
    uint256 public minStake = 0.01 ether;
    uint256 public constant MAX_WORKERS = 10;

    // ─── Constructor ───────────────────────────────────────────────────
    constructor(address _identityRegistry, address _reputationRegistry) Ownable(msg.sender) { ... }

    // ─── Core Functions ────────────────────────────────────────────────

    function createMarket(string calldata question, uint256 duration)
        external payable returns (uint256 marketId);

    function joinMarket(uint256 marketId, uint256 agentId) external payable;

    function resolveMarket(
        uint256 marketId,
        address[] calldata workers,
        uint256[] calldata weights,
        uint8[] calldata dimScores,
        bool resolution
    ) external;

    function requestResolution(uint256 marketId) external;

    function withdraw() external nonReentrant;

    function setAuthorizedResolver(address resolver, bool authorized) external onlyOwner;

    // ─── View Functions ────────────────────────────────────────────────

    function getMarket(uint256 marketId) external view returns (Market memory);
    function getMarketWorkers(uint256 marketId) external view returns (address[] memory);
    function isMarketActive(uint256 marketId) public view returns (bool);
    function getReputation(address worker) external view returns (uint256, uint256, uint256, uint256);
    function getScoringCriteria() external pure returns (string[8] memory, uint256[8] memory); // helper informativo
}
```

**Key implementation details**:

- **Constructor**: Accepts optional `_identityRegistry` and `_reputationRegistry` addresses. Pass `address(0)` to disable either.
- `createMarket`: Creates market with `msg.value` as reward pool, `block.timestamp + duration` as deadline
- `joinMarket`: Worker stakes ETH (≥ minStake). If `identityRegistry != address(0)`, verifies `isAuthorizedOrOwner(msg.sender, agentId)` and stores `workerAgentIds[marketId][worker] = agentId`.
- `resolveMarket`: Only callable by `authorizedResolvers`. Validates arrays match, workers registered, market not resolved. Distributes `rewardPool × weight[i] / totalWeight + stake[i]` to each worker's `balances`. Updates running-average reputation across 3 dimensions. If `reputationRegistry != address(0)`, publishes `giveFeedback()` to ERC-8004 for each worker with a registered agentId.
- `requestResolution`: Emits `ResolutionRequested(marketId, question)` event for CRE EVM Log Trigger
- `withdraw`: Pull-payment pattern with ReentrancyGuard

**ERC-8004 Integration**:
- Both registries are **optional** (`address(0)` = disabled) — E2E and demo run without them
- `identityRegistry.isAuthorizedOrOwner()` checks agent ownership on join
- `reputationRegistry.giveFeedback()` publishes avg score across 3 dims after resolution
- Sepolia addresses: Identity `0x8004A818BFB912233c491871b3d84c89A494BD9e`, Reputation `0x8004B663056A597Dffe9eCcC1965A193B7388713`

**Validations in resolveMarket**:
1. `!m.resolved` — Not already resolved
2. `m.deadline > 0` — Market exists
3. `workers.length <= MAX_WORKERS` — Max 10 workers
4. `workers.length == weights.length` — Arrays match
5. `dimScores.length == workers.length * 3` — 3 dims per worker
6. `authorizedResolvers[msg.sender]` — Caller authorized
7. `stakes[marketId][worker] > 0` for each worker — All registered

**Reputation formula**:
```
reputation.resQualitySum += dimScores[i*3 + 0]
reputation.srcQualitySum += dimScores[i*3 + 1]
reputation.analysisDepthSum += dimScores[i*3 + 2]
reputation.count++

getReputation() returns (sum/count, sum/count, sum/count, count)
```

### A.2 CREReceiver.sol

**File**: `contracts/src/CREReceiver.sol`

Bridge between KeystoneForwarder and CREsolverMarket.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ReceiverTemplate} from "./interfaces/ReceiverTemplate.sol";

interface ICREsolverMarket {
    function resolveMarket(
        uint256 marketId,
        address[] calldata workers,
        uint256[] calldata weights,
        uint8[] calldata dimScores,
        bool resolution
    ) external;
}

contract CREReceiver is ReceiverTemplate {
    ICREsolverMarket public immutable market;

    event ReportReceived(bytes32 indexed workflowId, uint256 indexed marketId);

    constructor(address _market, address _forwarder) ReceiverTemplate(_forwarder) {
        market = ICREsolverMarket(_market);
    }

    function _processReport(bytes calldata report) internal override {
        (
            uint256 marketId,
            address[] memory workers,
            uint256[] memory weights,
            uint8[] memory dimScores,
            bool resolution
        ) = abi.decode(report, (uint256, address[], uint256[], uint8[], bool));

        market.resolveMarket(marketId, workers, weights, dimScores, resolution);
        emit ReportReceived(bytes32(0), marketId);
    }
}
```

### A.3 ReceiverTemplate.sol

**File**: `contracts/src/interfaces/ReceiverTemplate.sol`

Abstract base contract implementing the Chainlink CRE receiver pattern:

```solidity
abstract contract ReceiverTemplate is IReceiver, Ownable {
    struct WorkflowIdentity {
        bytes32 workflowId;
        bytes32 workflowOwner;
        bytes32 donId;
    }

    address public forwarder;
    mapping(bytes32 => AllowedWorkflow) private _allowedWorkflows;
    bool public enforceWorkflowIdentity;

    function onReport(bytes calldata metadata, bytes calldata report) external override {
        if (msg.sender != forwarder) revert UnauthorizedForwarder(msg.sender);
        WorkflowIdentity memory identity = _decodeMetadata(metadata);
        if (enforceWorkflowIdentity) {
            // Check workflow whitelist
        }
        _processReport(report);
        emit ReportProcessed(identity.workflowId, identity.donId);
    }

    function _processReport(bytes calldata report) internal virtual;

    // Admin functions:
    function setForwarder(address) external onlyOwner;
    function allowWorkflow(bytes32 workflowId, bytes32 donId, string calldata name) external onlyOwner;
    function disallowWorkflow(bytes32 workflowId, bytes32 donId) external onlyOwner;
    function setEnforceWorkflowIdentity(bool enforce) external onlyOwner;
}
```

**Metadata decoding**: Expects minimum 64 bytes — `workflowId (32)` + `donId (32)`. Optional `workflowOwner` at bytes 64-96.

### A.4 IReceiver.sol

**File**: `contracts/src/interfaces/IReceiver.sol`

```solidity
interface IReceiver is IERC165 {
    function onReport(bytes calldata metadata, bytes calldata report) external;
}
```

### A.5 Deploy.s.sol

**File**: `contracts/script/Deploy.s.sol`

```solidity
contract DeployScript is Script {
    function run() external {
        address keystoneForwarder = vm.envOr("KEYSTONE_FORWARDER", address(0));
        address directResolver = vm.envOr("DIRECT_RESOLVER", address(0));
        address identityReg = vm.envOr("ERC8004_IDENTITY", address(0));
        address reputationReg = vm.envOr("ERC8004_REPUTATION", address(0));

        vm.startBroadcast();

        // 1. Deploy CREsolverMarket (ERC-8004 registries optional)
        CREsolverMarket market = new CREsolverMarket(identityReg, reputationReg);

        // 2. Deploy CREReceiver
        CREReceiver receiver = new CREReceiver(address(market), keystoneForwarder);

        // 3. Authorize CREReceiver as a resolver
        market.setAuthorizedResolver(address(receiver), true);

        // 4. Optionally authorize a direct signer for local demo
        if (directResolver != address(0)) {
            market.setAuthorizedResolver(directResolver, true);
        }

        vm.stopBroadcast();
    }
}
```

Usage:
```bash
# Local (Anvil) — no ERC-8004
forge script script/Deploy.s.sol --rpc-url http://localhost:8545 --broadcast

# With direct resolver for demo
DIRECT_RESOLVER=0x... forge script script/Deploy.s.sol --rpc-url http://localhost:8545 --broadcast

# Sepolia with ERC-8004 registries
ERC8004_IDENTITY=0x8004A818BFB912233c491871b3d84c89A494BD9e \
ERC8004_REPUTATION=0x8004B663056A597Dffe9eCcC1965A193B7388713 \
forge script script/Deploy.s.sol --rpc-url $SEPOLIA_RPC --broadcast
```

---

## PART B: CONTRACT TESTS

### B.1 CREsolverMarket.t.sol

**File**: `contracts/test/CREsolverMarket.t.sol` — 27 tests

**Setup**: `market = new CREsolverMarket(address(0), address(0))` — runs without ERC-8004 by default.
All `joinMarket` calls use `agentId=0`: `market.joinMarket{value: 0.05 ether}(marketId, 0)`.

| Test | What It Validates |
|------|-------------------|
| `test_createMarket` | Market creation with correct fields |
| `test_createMarket_reverts_empty_question` | EmptyQuestion error |
| `test_createMarket_reverts_zero_value` | ZeroValue error |
| `test_createMarket_reverts_invalid_duration` | InvalidDuration error |
| `test_joinMarket` | Worker joins with stake, stored correctly |
| `test_joinMarket_reverts_below_min_stake` | BelowMinStake error |
| `test_joinMarket_reverts_market_not_active` | MarketNotActive after deadline |
| `test_joinMarket_reverts_already_joined` | AlreadyJoined error |
| `test_joinMarket_with_identity_registry` | ERC-8004 identity check passes (vm.mockCall) |
| `test_joinMarket_reverts_not_agent_owner` | NotAgentOwner when identity check fails |
| `test_resolveMarket_happy_path` | 70/30 weight split → correct rewards + stakes |
| `test_resolveMarket_returns_stakes` | 50/50 split → stakes returned |
| `test_resolveMarket_publishes_reputation` | 3 dimensions stored correctly |
| `test_resolveMarket_publishes_erc8004_feedback` | giveFeedback() called with correct avg scores |
| `test_resolveMarket_reverts_unauthorized` | Unauthorized caller |
| `test_resolveMarket_reverts_already_resolved` | AlreadyResolved error |
| `test_resolveMarket_reverts_too_many_workers` | TooManyWorkers (>10) |
| `test_resolveMarket_reverts_array_mismatch` | ArrayMismatch error |
| `test_resolveMarket_reverts_unregistered_worker` | UnregisteredWorker error |
| `test_withdraw` | Withdraw transfers correct amount, zeroes balance |
| `test_withdraw_reverts_no_balance` | NoBalance error |
| `test_requestResolution_by_creator` | Emits ResolutionRequested event |
| `test_requestResolution_by_owner` | Owner can also request |
| `test_requestResolution_reverts_nonexistent_market` | MarketDoesNotExist error |
| `test_requestResolution_reverts_already_resolved` | MarketAlreadyResolved error |
| `test_requestResolution_reverts_unauthorized_caller` | NotMarketCreator error |
| `test_reputation_accumulates` | Multi-market reputation averaging |

### B.2 CREReceiver.t.sol

**File**: `contracts/test/CREReceiver.t.sol` — 9 tests

| Test | What It Validates |
|------|-------------------|
| `test_onReport_happy_path` | Full flow: forwarder → decode → resolveMarket → rewards |
| `test_onReport_reverts_unauthorized_forwarder` | UnauthorizedForwarder error |
| `test_onReport_reverts_short_metadata` | MetadataTooShort error |
| `test_onReport_emits_ReportProcessed` | Parent event with workflowId + donId |
| `test_onReport_emits_ReportReceived` | CREReceiver event with marketId |
| `test_setForwarder_only_owner` | onlyOwner access control |
| `test_setForwarder_updates` | Forwarder address changes + event |
| `test_workflow_identity_enforcement` | Whitelist enforcement + allowWorkflow |
| `test_supportsInterface` | ERC165: IReceiver + IERC165 |

---

## PART C: CRE RESOLUTION WORKFLOW

### C.1 Config (types.ts + config.json)

**Config schema (validated by CRE Runner via Zod)**:

```typescript
const ConfigSchema = z.object({
  evms: z.array(z.object({
    chain_selector: z.number(),
    market_address: z.string(),
    receiver_address: z.string(),
    gas_limit: z.number(),
  })).min(1),
  agents: z.array(z.object({
    name: z.string(),
    endpoint: z.string().url(),
  })).min(1),
});
```

**config.json example**:

```json
{
  "evms": [{
    "chain_selector": 31337,
    "market_address": "0x...",
    "receiver_address": "0x...",
    "gas_limit": 500000
  }],
  "agents": [
    { "name": "Alpha", "endpoint": "http://127.0.0.1:3101" },
    { "name": "Beta",  "endpoint": "http://127.0.0.1:3102" },
    { "name": "Gamma", "endpoint": "http://127.0.0.1:3103" }
  ]
}
```

### C.2 Workflow Types

```typescript
export interface WorkerData {
  address: string;
  endpoint: string;
  stake: bigint;
  reputation: { resQuality: number; srcQuality: number; analysisDepth: number; count: number };
}

export interface WorkerDetermination {
  determination: boolean;
  confidence: number;
  evidence: string;
  sources: string[];
  workerAddress: string;
}

export interface ChallengeResult {
  workerAddress: string;
  challenges: string[];
  responses: string[];
}

export interface WorkerEvaluation {
  workerAddress: string;
  qualityScore: number;
  resolutionQuality: number;
  sourceQuality: number;
  analysisDepth: number;
}

export interface ResolutionResult {
  resolution: boolean;
  workers: string[];
  weights: bigint[];
  dimScores: number[];
}
```

### C.3 main.ts — Entry Point

Two triggers, both calling the same `resolveMarket()` core function:

```typescript
function resolveMarket(runtime: Runtime<Config>, marketId: number): void {
  // Step 1: Read market data and worker info from chain
  const question = readMarketQuestion(runtime, evmClient, marketId);
  const workers = readMarketWorkers(runtime, evmClient, marketId);

  // Step 2: Query all agents for their determinations
  const determinations = queryAllAgents(runtime, workers, marketId, question);

  // Step 3: Challenge workers
  const challengeResults = challengeAllAgents(runtime, workers, determinations);

  // Step 4: Evaluate worker quality
  const evaluations = evaluateWorkers(determinations, challengeResults);

  // Step 5: Compute weighted majority vote + blinded weights
  const resolution = computeResolution(determinations, evaluations, workers);

  // Step 6: Submit resolution on-chain via signed report
  submitResolution(runtime, evmClient, marketId, resolution);
}
```

**EVM Log Trigger**: Listens for `ResolutionRequested(uint256,string)` events. Extracts `marketId` from `log.topics[1]`.

**HTTP Trigger**: Accepts `{ market_id: number }` in the request body.

### C.4 evm.ts — On-chain Client

Uses `@chainlink/cre-sdk` EVMClient with `viem` for ABI encoding:

**`readMarketWorkers()`**:
1. Calls `getMarket(marketId)` — validates market not already resolved
2. Calls `getMarketWorkers(marketId)` — gets worker addresses
3. For each worker: calls `stakes(marketId, worker)` and `getReputation(worker)`
4. Maps workers to agent endpoints from config (by index)
5. Returns `WorkerData[]`

**`readMarketQuestion()`**: Calls `getMarket(marketId)`, returns `question` string.

**`submitResolution()`**:
1. Encodes payload: `encodeAbiParameters([uint256, address[], uint256[], uint8[], bool], [marketId, workers, weights, dimScores, resolution])`
2. Signs via DON: `runtime.report(prepareReportRequest(encodedPayload))`
3. Writes to chain: `evmClient.writeReport(runtime, { receiver, report, gasConfig })`

### C.5 agents.ts — Worker HTTP Client

**`queryAllAgents()`**: For each worker, sends `POST /a2a/resolve` with `{ market_id, question }`. Uses `runtime.runInNodeMode()` + `consensusIdenticalAggregation` to ensure all DON nodes get identical results. Returns `WorkerDetermination[]`.

**`challengeAllAgents()`**: For each determination, generates challenges via `generateChallenges()`, then sends `POST /a2a/challenge` with `{ challenges }`. Same CRE consensus pattern.

### C.6 evaluate.ts — Scoring & Consensus

**`evaluateWorkers()`**: Scores each worker across 3 dimensions:

| Dimension | How Scored |
|-----------|-----------|
| Resolution Quality | Base 40 + evidence length (up to 30) + confidence calibration (±10) + sources count (up to 20) |
| Source Quality | Base 30 + source count (up to 30) + domain diversity (up to 20) + evidence references (+10) |
| Analysis Depth | Base 30 + evidence length (up to 25) + challenge response quality (up to 25) + completeness (+10) |

**Aggregate**: `qualityScore = resolutionQuality × 0.4 + sourceQuality × 0.3 + analysisDepth × 0.3`

**`computeResolution()`**: Weighted majority vote + blinded weight computation:

```typescript
// Vote weighting
const repFactor = count > 0 ? (avgRep / 100 + 0.5) : 1.0;
const voteWeight = qualityScore * repFactor;
// Accumulate into yesWeight or noWeight based on determination

// Blinded on-chain weights
const correctnessMult = determination === resolution ? 200 : 50;
const weight = Math.round(qualityScore * correctnessMult * repFactor);
```

**`generateChallenges()`**: Creates 3 contextual challenges per worker:
- If disagreement exists: "Why are you confident?", "What would change your mind?", "Weakest point?"
- If consensus: "Devil's advocate?", "Assumptions that could be wrong?", "Biased sources?"

### C.7 project.yaml & workflow.yaml

**project.yaml**:
```yaml
project_name: cresolver
language: typescript
targets:
  local-simulation:
    rpc_urls:
      - chain_id: 31337
        url: "http://127.0.0.1:8547"
```

**workflow.yaml**:
```yaml
name: cresolver-resolution
description: "CRE workflow for resolving prediction markets using multi-agent consensus"
artifact:
  entry_point: main.ts
  build_dir: dist
config:
  path: config.json
secrets:
  path: ../secrets.yaml
```

---

## PART D: WORKER AGENT

### D.1 Server (index.ts)

```typescript
import { Hono } from "hono";
import { serve } from "@hono/node-server";

export const app = new Hono();
app.route("/", healthRoutes);
app.route("/", a2aRoutes);

// Only start server when run directly (not imported for tests)
if (isDirectRun) {
  serve({ fetch: app.fetch, port: config.port });
}
```

### D.2 Config (config.ts)

```typescript
export const config = {
  port: parseInt(process.env.AGENT_PORT || "3001", 10),
  name: process.env.AGENT_NAME || "Worker",
  llmApiKey: process.env.LLM_API_KEY || "",
  llmModel: process.env.LLM_MODEL || "gpt-4o-mini",
  get isLlmMode(): boolean { return this.llmApiKey.length > 0; },
  get mode(): "llm" | "mock" { return this.isLlmMode ? "llm" : "mock"; },
};
```

### D.3 Validation (validation.ts)

```typescript
export const resolveRequestSchema = z.object({
  market_id: z.number().int().min(0),
  question: z.string().min(1),
  deadline: z.number().optional(),
  context: z.string().optional(),
});

export const challengeRequestSchema = z.object({
  challenges: z.array(z.string().min(1)).min(1),
});
```

### D.4 Routes (a2a.ts)

```typescript
a2aRoutes.post("/a2a/resolve", async (c) => {
  const body = await c.req.json();
  const parsed = resolveRequestSchema.safeParse(body);
  if (!parsed.success) return c.json({ error: "Invalid request", details: parsed.error.flatten() }, 400);
  const result = await investigate(parsed.data.question, parsed.data.market_id);
  return c.json(result);
});

a2aRoutes.post("/a2a/challenge", async (c) => {
  const body = await c.req.json();
  const parsed = challengeRequestSchema.safeParse(body);
  if (!parsed.success) return c.json({ error: "Invalid request", details: parsed.error.flatten() }, 400);
  const responses = await defend(parsed.data.challenges);
  return c.json({ responses });
});
```

### D.5 Investigator (investigator.ts)

**Mock mode** (no API key): Deterministic keyword-based responses:
- `"bitcoin" + "200k"` → `{ determination: false, confidence: 0.65, evidence: "...", sources: [...] }`
- `"ethereum" + "pos"` → `{ determination: true, confidence: 0.99, ... }`
- `"etf"` → `{ determination: true, confidence: 0.72, ... }`
- Default → hash-based: `determination = hash(question) % 2 === 0`

**LLM mode** (with `LLM_API_KEY`):
- OpenAI chat completion with `temperature: 0`, `seed: 42` for determinism
- System prompt instructs structured JSON output
- Retry with exponential backoff (3 attempts)

**Caching**: Both modes cache responses by `marketId` with 10-minute TTL. Critical for CRE consensus — all DON nodes must get identical responses from the same agent.

### D.6 Defender (defender.ts)

**Mock mode**: Template-based responses keyed on challenge content:
- Evidence/proof challenges → multi-source verification response
- Bias/assumption challenges → multi-viewpoint methodology response
- Confidence/certainty challenges → evidence-strength explanation
- Default → systematic review response

**LLM mode**: Same OpenAI pattern as investigator, with defense-specific system prompt.

**Caching**: Responses cached by challenge array hash with 10-minute TTL.

### D.7 Dockerfile

```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package.json yarn.lock ./
RUN yarn install --frozen-lockfile
COPY . .
EXPOSE 3000
CMD ["node", "--import", "tsx", "src/index.ts"]
```

---

## PART E: E2E TESTING

### E.1 Docker Compose (docker-compose.e2e.yml)

```yaml
services:
  anvil:
    image: ghcr.io/foundry-rs/foundry:latest
    entrypoint: ["anvil", "--host", "0.0.0.0"]
    ports: ["8547:8545"]
    healthcheck:
      test: ["CMD", "cast", "block-number", "--rpc-url", "http://127.0.0.1:8545"]

  agent-alpha:
    build: ./agent
    ports: ["3101:3000"]
    environment: [AGENT_PORT=3000, AGENT_NAME=Alpha]

  agent-beta:
    build: ./agent
    ports: ["3102:3000"]
    environment: [AGENT_PORT=3000, AGENT_NAME=Beta]

  agent-gamma:
    build: ./agent
    ports: ["3103:3000"]
    environment: [AGENT_PORT=3000, AGENT_NAME=Gamma]
```

### E.2 Setup (shared `setup-demo.ts`, profile `e2e`)

1. Runs from root script: `yarn e2e:setup` (or `cd e2e && yarn setup`)
2. Waits for Anvil to be ready (polls block number)
3. Waits for 3 agents to be healthy (polls `/health`)
4. Deploys `CREsolverMarket(ethers.ZeroAddress, ethers.ZeroAddress)` for E2E (no ERC-8004)
5. Authorizes deployer as resolver (for E2E without CRE DON)
6. Creates 3 demo markets with reward pools (0.1, 0.05, 0.08 ETH)
7. Has 3 workers join each market with `joinMarket(m, 0, { value: ... })` (agentId=0)
8. Writes `e2e/demo-config.json` with addresses and config

### E.3 Helpers (helpers.ts)

- `waitForAnvil(rpcUrl)` — Polls `eth_blockNumber` with retries
- `waitForAgent(url, name)` — Polls `/health` endpoint with retries
- `createOnChainVerifier(config)` — Creates ethers.js contract interface for verification
- `loadDemoConfig()` — Reads demo-config.json

### E.4 Workflow Runner (workflow-runner.ts)

Local orchestrator that mirrors CRE DON behavior:
1. Reads market data from chain
2. Queries agents via HTTP
3. Generates challenges and queries agents
4. Evaluates quality scores
5. Computes resolution
6. Calls `resolveMarket()` directly (simulates DON-signed report)

### E.5 Test Suite (e2e.test.ts)

18 tests covering:
- Agent health checks (all 3 agents healthy, mock mode, caching)
- Market resolution workflows (independent markets, correct evaluations, reputation updates)
- Edge cases (consensus handling, weight computation, dimension score aggregation)

**Config**: 120s timeout per test, sequential execution.

### E.6 Root Scripts (package.json)

```json
{
  "scripts": {
    "e2e": "yarn e2e:up && yarn e2e:setup && yarn e2e:test; yarn e2e:down",
    "e2e:up": "docker compose -f docker-compose.e2e.yml up -d --build --wait",
    "e2e:setup": "cd scripts && npx tsx setup-demo.ts --profile e2e --output ../e2e/demo-config.json",
    "e2e:test": "cd e2e && npx vitest run --config vitest.e2e.config.ts",
    "e2e:down": "docker compose -f docker-compose.e2e.yml down"
  }
}
```

---

## PART F: SCRIPTS

### F.1 setup-demo.ts

Automates local demo setup:

1. Waits for Anvil (`RPC_URL` default: `http://127.0.0.1:8545`)
2. Waits for 3 agents on ports 3001-3003
3. Deploys CREsolverMarket (reads compiled artifact from `contracts/out/`)
4. Authorizes deployer as resolver
5. Creates 3 markets:
   - "Will bitcoin reach 200k by end of 2026?" (0.1 ETH)
   - "Has ethereum successfully transitioned to pos consensus?" (0.05 ETH)
   - "Will a spot bitcoin etf be approved in 2024?" (0.08 ETH)
6. Workers join all markets with 0.01 ETH stake
7. Writes `demo-config.json`:

```json
{
  "rpcUrl": "http://127.0.0.1:8545",
  "contractAddress": "0x...",
  "resolverPrivateKey": "0x...",
  "workerEndpoints": { "0x...": "http://...", ... },
  "workers": [{ "name": "Alpha", "address": "0x...", "privateKey": "0x...", "port": 3001 }, ...],
  "marketCount": 3
}
```

### F.2 demo-run.ts

Executes resolution for a specific market:

```bash
yarn demo       # resolves market 0
yarn demo 1     # resolves market 1
yarn demo 2     # resolves market 2
```

Flow:
1. Reads `demo-config.json`
2. Validates market exists
3. Checks agent health
4. Queries each worker: `POST /a2a/resolve`
5. Generates challenges, queries: `POST /a2a/challenge`
6. Evaluates quality scores
7. Computes resolution (weighted majority + blinded weights)
8. Calls `resolveMarket()` on-chain
9. Prints results + updated reputation

---

## PART G: SHARED TYPES

**File**: `shared/types.ts`

```typescript
// ─── Contract types (mirror CREsolverMarket.sol) ────────────────────────────

export interface Market {
  question: string;
  rewardPool: bigint;
  deadline: bigint;
  creator: string;
  resolved: boolean;
}

export interface Reputation {
  resQuality: number;
  srcQuality: number;
  analysisDepth: number;
  count: number;
}

// ─── A2A Protocol ────────────────────────────────────────────────────────────

export interface ResolveRequest {
  market_id: number;
  question: string;
  deadline?: number;
  context?: string;
}

export interface ResolveResponse {
  determination: boolean;
  confidence: number;
  evidence: string;
  sources: string[];
}

export interface ChallengeRequest {
  challenges: string[];
}

export interface ChallengeResponse {
  responses: string[];
}

// ─── Workflow internal ───────────────────────────────────────────────────────

export interface WorkerInfo {
  address: string;
  endpoint: string;
  stake: bigint;
  reputation: Reputation;
}

export interface WorkerDetermination extends ResolveResponse {
  workerAddress: string;
}

export interface WorkerEvaluation {
  workerAddress: string;
  qualityScore: number;
  resolutionQuality: number;
  sourceQuality: number;
  analysisDepth: number;
}

export interface ResolutionResult {
  resolution: boolean;
  workers: string[];
  weights: bigint[];
  dimScores: number[];
}
```

---

## Running Everything

### Contract Tests

```bash
cd contracts
forge test -vvv
```

### Agent Tests

```bash
cd agent
yarn test
```

### CRE Workflow Typecheck

```bash
cd cre-workflow/cresolver-resolution
yarn typecheck
```

### E2E (Full Lifecycle)

```bash
yarn e2e
```

### Local Demo (Without Docker)

```bash
# Terminal 1: Anvil
anvil

# Terminals 2-4: Agents
cd agent
AGENT_PORT=3001 AGENT_NAME=Alpha yarn start
AGENT_PORT=3002 AGENT_NAME=Beta  yarn start
AGENT_PORT=3003 AGENT_NAME=Gamma yarn start

# Terminal 5: Setup + Run
cd scripts
yarn setup
yarn demo      # market 0
yarn demo 1    # market 1
yarn demo 2    # market 2
```
