/**
 * Register 3 agents on Sepolia ERC-8004 IdentityRegistry.
 *
 * Reads wallets from scripts/sepolia-agents.json (generated by generate-wallets.ts).
 * For each agent:
 *   1. Calls register("CREsolver Agent <Name>") → mints agent NFT (deployer is owner)
 *   2. Calls approve(workerAddress, agentId) → so worker can pass isAuthorizedOrOwner
 *   3. Calls setMetadata(agentId, "workerAddress", abi.encode(address))
 *   4. Funds worker wallet with Sepolia ETH (for joinMarket later)
 *
 * Updates sepolia-agents.json with agentIds.
 *
 * Usage:
 *   DEPLOYER_KEY=0x... SEPOLIA_RPC=https://... npx tsx scripts/register-agents.ts
 *
 * Optional:
 *   FUND_AMOUNT=0.05    # ETH to send to each worker (default: 0.05)
 */

import { ethers } from "ethers";
import { readFileSync, writeFileSync } from "node:fs";
import { resolve, dirname } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const AGENTS_PATH = resolve(__dirname, "sepolia-agents.json");

// ─── ABI (only the functions we need) ────────────────────────────────────────

const IdentityRegistryABI = [
  // register(string agentURI) → returns agentId
  "function register(string agentURI) external returns (uint256 agentId)",
  // ERC-721 approve
  "function approve(address to, uint256 tokenId) external",
  // setMetadata
  "function setMetadata(uint256 agentId, string metadataKey, bytes metadataValue) external",
  // isAuthorizedOrOwner (for verification)
  "function isAuthorizedOrOwner(address spender, uint256 agentId) external view returns (bool)",
  // ownerOf (for verification)
  "function ownerOf(uint256 tokenId) external view returns (address)",
  // Events
  "event Registered(uint256 indexed agentId, string agentURI, address indexed owner)",
  "event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)",
];

// ─── Types ───────────────────────────────────────────────────────────────────

interface AgentEntry {
  name: string;
  address: string;
  privateKey: string;
  agentId: number | null;
}

interface SepoliaAgentsConfig {
  network: string;
  chainId: number;
  identityRegistry: string;
  reputationRegistry: string;
  agents: AgentEntry[];
}

// ─── Main ────────────────────────────────────────────────────────────────────

async function main() {
  // Validate env
  const deployerKey = process.env.DEPLOYER_KEY;
  const rpcUrl = process.env.SEPOLIA_RPC;
  const fundAmount = process.env.FUND_AMOUNT || "0.05";

  if (!deployerKey) {
    console.error("  Missing DEPLOYER_KEY env var");
    process.exit(1);
  }
  if (!rpcUrl) {
    console.error("  Missing SEPOLIA_RPC env var");
    process.exit(1);
  }

  // Load agents config
  let config: SepoliaAgentsConfig;
  try {
    config = JSON.parse(readFileSync(AGENTS_PATH, "utf-8"));
  } catch {
    console.error(`  Could not read ${AGENTS_PATH}`);
    console.error("  Run 'npx tsx scripts/generate-wallets.ts' first");
    process.exit(1);
  }

  // Check if already registered
  const alreadyRegistered = config.agents.filter((a) => a.agentId !== null);
  if (alreadyRegistered.length === config.agents.length) {
    console.log("\n  All agents already registered:");
    for (const a of config.agents) {
      console.log(`    ${a.name}: agentId=${a.agentId} (${a.address})`);
    }
    console.log("\n  Nothing to do. Delete sepolia-agents.json to start over.\n");
    return;
  }

  console.log("\n  Registering agents on Sepolia ERC-8004 IdentityRegistry\n");

  // Connect
  const provider = new ethers.JsonRpcProvider(rpcUrl);
  const network = await provider.getNetwork();
  console.log(`  Network: ${network.name} (chainId: ${network.chainId})`);

  const deployer = new ethers.Wallet(deployerKey, provider);
  const deployerBalance = await provider.getBalance(deployer.address);
  console.log(`  Deployer: ${deployer.address}`);
  console.log(`  Balance: ${ethers.formatEther(deployerBalance)} ETH\n`);

  if (deployerBalance < ethers.parseEther("0.01")) {
    console.error("  Deployer balance too low. Fund it with Sepolia ETH first.");
    process.exit(1);
  }

  const identity = new ethers.Contract(
    config.identityRegistry,
    IdentityRegistryABI,
    deployer,
  );

  // Register each agent
  for (const agent of config.agents) {
    if (agent.agentId !== null) {
      console.log(`  ${agent.name}: already registered (agentId=${agent.agentId}), skipping`);
      continue;
    }

    console.log(`  --- ${agent.name} ---`);
    console.log(`    Worker wallet: ${agent.address}`);

    // 1. Register agent
    console.log(`    Registering on IdentityRegistry...`);
    const agentURI = `CREsolver Agent ${agent.name}`;
    const registerTx = await identity.register(agentURI);
    const receipt = await registerTx.wait();

    // Parse agentId from Registered event
    const registeredEvent = receipt.logs
      .map((log: ethers.Log) => {
        try {
          return identity.interface.parseLog({ topics: [...log.topics], data: log.data });
        } catch {
          return null;
        }
      })
      .find((e: ethers.LogDescription | null) => e?.name === "Registered");

    if (!registeredEvent) {
      // Fallback: parse from Transfer event (ERC-721 mint)
      const transferEvent = receipt.logs
        .map((log: ethers.Log) => {
          try {
            return identity.interface.parseLog({ topics: [...log.topics], data: log.data });
          } catch {
            return null;
          }
        })
        .find((e: ethers.LogDescription | null) => e?.name === "Transfer");

      if (!transferEvent) {
        console.error(`    Failed to parse agentId from tx ${receipt.hash}`);
        process.exit(1);
      }
      agent.agentId = Number(transferEvent.args.tokenId);
    } else {
      agent.agentId = Number(registeredEvent.args.agentId);
    }

    console.log(`    Registered: agentId = ${agent.agentId}`);

    // 2. Approve worker wallet (so isAuthorizedOrOwner returns true)
    console.log(`    Approving worker wallet...`);
    const approveTx = await identity.approve(agent.address, agent.agentId);
    await approveTx.wait();

    // 3. Set metadata with worker address
    console.log(`    Setting workerAddress metadata...`);
    const encodedAddress = ethers.AbiCoder.defaultAbiCoder().encode(
      ["address"],
      [agent.address],
    );
    const metadataTx = await identity.setMetadata(
      agent.agentId,
      "workerAddress",
      encodedAddress,
    );
    await metadataTx.wait();

    // 4. Verify
    const isAuthorized = await identity.isAuthorizedOrOwner(agent.address, agent.agentId);
    console.log(`    isAuthorizedOrOwner: ${isAuthorized}`);

    if (!isAuthorized) {
      console.error(`    WARNING: Worker is not authorized for agentId ${agent.agentId}`);
    }

    // 5. Fund worker wallet
    console.log(`    Funding with ${fundAmount} ETH...`);
    const fundTx = await deployer.sendTransaction({
      to: agent.address,
      value: ethers.parseEther(fundAmount),
    });
    await fundTx.wait();

    const workerBalance = await provider.getBalance(agent.address);
    console.log(`    Worker balance: ${ethers.formatEther(workerBalance)} ETH`);
    console.log();
  }

  // Save updated config with agentIds
  writeFileSync(AGENTS_PATH, JSON.stringify(config, null, 2));

  console.log("  Updated sepolia-agents.json with agentIds\n");

  // Summary
  console.log("  ┌─────────────────────────────────────────────────────────┐");
  console.log("  │  Registration Complete                                  │");
  console.log("  ├─────────────────────────────────────────────────────────┤");
  for (const agent of config.agents) {
    console.log(
      `  │  ${agent.name.padEnd(6)} │ agentId: ${String(agent.agentId).padEnd(6)} │ ${agent.address.slice(0, 18)}... │`,
    );
  }
  console.log("  └─────────────────────────────────────────────────────────┘");
  console.log(`\n  Identity: ${config.identityRegistry}`);
  console.log(`  Reputation: ${config.reputationRegistry}`);
  console.log(`\n  Next: deploy CREsolverMarket on Sepolia and run the demo\n`);
}

main().catch((err) => {
  console.error("Registration failed:", err);
  process.exit(1);
});
