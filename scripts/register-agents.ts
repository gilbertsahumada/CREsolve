/**
 * Register 3 agents on Sepolia ERC-8004 IdentityRegistry.
 *
 * Reads wallets from scripts/sepolia-agents.json (generated by generate-wallets.ts).
 * For each agent:
 *   1. Calls register("CREsolver Agent <Name>") → mints agent NFT (deployer is owner)
 *   2. Calls setAgentURI(agentId, data:application/json;base64,<registration-v1>)
 *   3. Calls approve(workerAddress, agentId) → so worker can pass isAuthorizedOrOwner
 *   4. Calls setMetadata for worker/owner/registry/profileVersion keys
 *   5. Funds worker wallet with Sepolia ETH (for joinMarket later)
 *
 * Updates sepolia-agents.json with agentIds.
 * Also writes:
 *   - scripts/sepolia-agents.public.json (no private keys)
 *   - contracts/SEPOLIA_AGENTS.md (public markdown table)
 *
 * Metadata/profile schema source of truth:
 *   - scripts/agent-profile.ts
 *
 * Usage:
 *   DEPLOYER_KEY=0x... SEPOLIA_RPC=https://... npx tsx scripts/register-agents.ts
 *
 * Optional:
 *   FUND_AMOUNT=0.05    # ETH to send to each worker (default: 0.05)
 */

import { ethers } from "ethers";
import { readFileSync, writeFileSync } from "node:fs";
import { resolve, dirname } from "node:path";
import { fileURLToPath } from "node:url";
import {
  buildAgentDataUri,
  buildOnchainMetadataEntries,
  type AgentProfileContext,
  type AgentProfileInput,
} from "./agent-profile.js";

const __dirname = dirname(fileURLToPath(import.meta.url));
const AGENTS_PATH = resolve(__dirname, "sepolia-agents.json");
const PUBLIC_AGENTS_PATH = resolve(__dirname, "sepolia-agents.public.json");
const PUBLIC_DOCS_PATH = resolve(__dirname, "../contracts/SEPOLIA_AGENTS.md");

// ─── ABI (only the functions we need) ────────────────────────────────────────

const IdentityRegistryABI = [
  // register(string agentURI) → returns agentId
  "function register(string agentURI) external returns (uint256 agentId)",
  // setAgentURI (ERC-8004)
  "function setAgentURI(uint256 agentId, string newURI) external",
  // ERC-721 approve
  "function approve(address to, uint256 tokenId) external",
  // setMetadata
  "function setMetadata(uint256 agentId, string metadataKey, bytes metadataValue) external",
  // isAuthorizedOrOwner (for verification)
  "function isAuthorizedOrOwner(address spender, uint256 agentId) external view returns (bool)",
  // ownerOf (for verification)
  "function ownerOf(uint256 tokenId) external view returns (address)",
  // Events
  "event Registered(uint256 indexed agentId, string agentURI, address indexed owner)",
  "event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)",
];

// ─── Types ───────────────────────────────────────────────────────────────────

interface AgentEntry {
  name: string;
  address: string;
  privateKey: string;
  agentId: number | null;
}

interface SepoliaAgentsConfig {
  network: string;
  chainId: number;
  identityRegistry: string;
  reputationRegistry: string;
  agents: AgentEntry[];
}

function writePublicArtifacts(config: SepoliaAgentsConfig, deployerAddress: string) {
  const generatedAt = new Date().toISOString();
  const publicView = {
    network: config.network,
    chainId: config.chainId,
    identityRegistry: config.identityRegistry,
    reputationRegistry: config.reputationRegistry,
    deployer: deployerAddress,
    generatedAt,
    agents: config.agents.map((a) => ({
      name: a.name,
      address: a.address,
      agentId: a.agentId,
    })),
  };

  writeFileSync(PUBLIC_AGENTS_PATH, JSON.stringify(publicView, null, 2));

  const rows = config.agents
    .map(
      (a) =>
        `| ${a.name} | \`${a.address}\` | \`${a.agentId ?? "null"}\` |`,
    )
    .join("\n");

  const markdown = `# Sepolia Agents (Public)

Last updated: ${generatedAt}

## Registry Config

- Network: ${config.network}
- Chain ID: ${config.chainId}
- Identity Registry: \`${config.identityRegistry}\`
- Reputation Registry: \`${config.reputationRegistry}\`
- Deployer: \`${deployerAddress}\`

## Agents

| Name | Worker Address | Agent ID |
|---|---|---:|
${rows}

## Source

- Machine-readable file: \`scripts/sepolia-agents.public.json\`
- Private keys remain only in \`scripts/sepolia-agents.json\` (gitignored)
`;

  writeFileSync(PUBLIC_DOCS_PATH, markdown);
}

// ─── Main ────────────────────────────────────────────────────────────────────

async function main() {
  // Validate env
  const deployerKey = process.env.DEPLOYER_KEY;
  const rpcUrl = process.env.SEPOLIA_RPC;
  const fundAmount = process.env.FUND_AMOUNT || "0.05";

  if (!deployerKey) {
    console.error("  Missing DEPLOYER_KEY env var");
    process.exit(1);
  }
  if (!rpcUrl) {
    console.error("  Missing SEPOLIA_RPC env var");
    process.exit(1);
  }

  // Load agents config
  let config: SepoliaAgentsConfig;
  try {
    config = JSON.parse(readFileSync(AGENTS_PATH, "utf-8"));
  } catch {
    console.error(`  Could not read ${AGENTS_PATH}`);
    console.error("  Run 'npx tsx scripts/generate-wallets.ts' first");
    process.exit(1);
  }

  // Check if already registered
  const alreadyRegistered = config.agents.filter((a) => a.agentId !== null);
  if (alreadyRegistered.length === config.agents.length) {
    const deployerAddress = new ethers.Wallet(deployerKey).address;
    writePublicArtifacts(config, deployerAddress);

    console.log("\n  All agents already registered:");
    for (const a of config.agents) {
      console.log(`    ${a.name}: agentId=${a.agentId} (${a.address})`);
    }
    console.log(`\n  Public file: ${PUBLIC_AGENTS_PATH}`);
    console.log(`  Public docs: ${PUBLIC_DOCS_PATH}`);
    console.log("\n  Nothing else to do. Delete sepolia-agents.json to start over.\n");
    return;
  }

  console.log("\n  Registering agents on Sepolia ERC-8004 IdentityRegistry\n");

  // Connect
  const provider = new ethers.JsonRpcProvider(rpcUrl);
  const network = await provider.getNetwork();
  console.log(`  Network: ${network.name} (chainId: ${network.chainId})`);

  if (Number(network.chainId) !== config.chainId) {
    console.error(
      `  Chain mismatch: config chainId=${config.chainId}, rpc chainId=${network.chainId}`,
    );
    process.exit(1);
  }

  const deployer = new ethers.Wallet(deployerKey, provider);
  const deployerBalance = await provider.getBalance(deployer.address);
  console.log(`  Deployer: ${deployer.address}`);
  console.log(`  Balance: ${ethers.formatEther(deployerBalance)} ETH\n`);

  if (deployerBalance < ethers.parseEther("0.01")) {
    console.error("  Deployer balance too low. Fund it with Sepolia ETH first.");
    process.exit(1);
  }

  const identity = new ethers.Contract(
    config.identityRegistry,
    IdentityRegistryABI,
    deployer,
  );
  const abi = ethers.AbiCoder.defaultAbiCoder();
  const profileContext: AgentProfileContext = {
    chainId: network.chainId,
    identityRegistry: config.identityRegistry,
  };

  // Register each agent
  for (const agent of config.agents) {
    if (agent.agentId !== null) {
      console.log(`  ${agent.name}: already registered (agentId=${agent.agentId}), skipping`);
      continue;
    }

    console.log(`  --- ${agent.name} ---`);
    console.log(`    Worker wallet: ${agent.address}`);

    // 1. Register agent
    console.log(`    Registering on IdentityRegistry...`);
    const agentURI = `CREsolver Agent ${agent.name}`;
    const registerTx = await identity.register(agentURI);
    const receipt = await registerTx.wait();

    // Parse agentId from Registered event
    const registeredEvent = receipt.logs
      .map((log: ethers.Log) => {
        try {
          return identity.interface.parseLog({ topics: [...log.topics], data: log.data });
        } catch {
          return null;
        }
      })
      .find((e: ethers.LogDescription | null) => e?.name === "Registered");

    if (!registeredEvent) {
      // Fallback: parse from Transfer event (ERC-721 mint)
      const transferEvent = receipt.logs
        .map((log: ethers.Log) => {
          try {
            return identity.interface.parseLog({ topics: [...log.topics], data: log.data });
          } catch {
            return null;
          }
        })
        .find((e: ethers.LogDescription | null) => e?.name === "Transfer");

      if (!transferEvent) {
        console.error(`    Failed to parse agentId from tx ${receipt.hash}`);
        process.exit(1);
      }
      agent.agentId = Number(transferEvent.args.tokenId);
    } else {
      agent.agentId = Number(registeredEvent.args.agentId);
    }

    console.log(`    Registered: agentId = ${agent.agentId}`);

    // 2. Set agentURI with registration-v1 profile (data URI)
    console.log("    Setting registration-v1 agentURI...");
    const profileAgent: AgentProfileInput = {
      name: agent.name,
      address: agent.address,
      agentId: agent.agentId,
    };
    const dataUri = buildAgentDataUri(profileAgent, profileContext);
    const setUriTx = await identity.setAgentURI(agent.agentId, dataUri);
    await setUriTx.wait();

    // 3. Approve worker wallet (so isAuthorizedOrOwner returns true)
    console.log(`    Approving worker wallet...`);
    const approveTx = await identity.approve(agent.address, agent.agentId);
    await approveTx.wait();

    // 4. Set metadata fields
    console.log(`    Setting metadata keys...`);
    const metadataEntries = buildOnchainMetadataEntries(
      profileAgent,
      profileContext,
      deployer.address,
    );
    for (const entry of metadataEntries) {
      const metadataTx = await identity.setMetadata(
        agent.agentId,
        entry.key,
        abi.encode([entry.abiType], [entry.value]),
      );
      await metadataTx.wait();
      console.log(`    setMetadata(${entry.key}): ok`);
    }

    // 4. Verify
    const isAuthorized = await identity.isAuthorizedOrOwner(agent.address, agent.agentId);
    console.log(`    isAuthorizedOrOwner: ${isAuthorized}`);

    if (!isAuthorized) {
      console.error(`    WARNING: Worker is not authorized for agentId ${agent.agentId}`);
    }

    // 5. Fund worker wallet
    console.log(`    Funding with ${fundAmount} ETH...`);
    const fundTx = await deployer.sendTransaction({
      to: agent.address,
      value: ethers.parseEther(fundAmount),
    });
    await fundTx.wait();

    const workerBalance = await provider.getBalance(agent.address);
    console.log(`    Worker balance: ${ethers.formatEther(workerBalance)} ETH`);
    console.log();
  }

  // Save updated config with agentIds
  writeFileSync(AGENTS_PATH, JSON.stringify(config, null, 2));
  writePublicArtifacts(config, deployer.address);

  console.log("  Updated sepolia-agents.json with agentIds\n");
  console.log(`  Public file: ${PUBLIC_AGENTS_PATH}`);
  console.log(`  Public docs: ${PUBLIC_DOCS_PATH}\n`);

  // Summary
  console.log("  ┌─────────────────────────────────────────────────────────┐");
  console.log("  │  Registration Complete                                  │");
  console.log("  ├─────────────────────────────────────────────────────────┤");
  for (const agent of config.agents) {
    console.log(
      `  │  ${agent.name.padEnd(6)} │ agentId: ${String(agent.agentId).padEnd(6)} │ ${agent.address.slice(0, 18)}... │`,
    );
  }
  console.log("  └─────────────────────────────────────────────────────────┘");
  console.log(`\n  Identity: ${config.identityRegistry}`);
  console.log(`  Reputation: ${config.reputationRegistry}`);
  console.log(`\n  Next: deploy CREsolverMarket on Sepolia and run the demo\n`);
}

main().catch((err) => {
  console.error("Registration failed:", err);
  process.exit(1);
});
